#### Java GC 总结
##### 一、串行 GC
1. 串行 GC 在进行垃圾回收时，它会停止所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作
2. 垃圾收集算法：年轻代采用复制算法，老年代采用标记-压缩算法
3. 串行 GC 采用分代的内存划分方式
4. 年轻代收集步骤：
   1. 找出 Eden 中存活的对象
   2. 将存活的对象移动至 To 区
   3. 释放整个 Eden 区
   4. 交换 From 区和 To 区
5. 老年代收集步骤：
   1. 标记存活的对象
   2. 计算存活对象的新位置
   3. 移动存活的对象
   4. 释放其他内存
---

##### 二、并行 GC
1. 并行 GC 可看做串行 GC 的多线程版本
2. 垃圾收集算法：年轻代采用复制算法，老年代采用标记-压缩算法
3. 并行 GC 采用分代的内存划分方式
---

##### 三、CMS GC
1. CMS GC 采用标记-清除算法
2. CMS GC 采用分代的内存划分方式
3. 收集步骤：
   1. Initial Marking：初始化标记阶段，需要暂停所有应用线程。这一阶段主要标记可达的对象
   2. Concurrent Mark：并发标记阶段，GC 线程和应用线程并行运行。这一阶段遍历前一个阶段标记出来的对象，并通过它们查找间接可达的对象。对于在本阶段执行时发生变化的对象，需要重新标记为 Dirty 以防止遗漏
   3. Concurrent Preclean：并发预清理，GC线程与应用线程并行运行。这一阶段将扫描第二个阶段被标记为 Dirty 的对象，并标记通过 Dirty 对象可达的对象，之后清除标记
   4. Concurrent Abortable Preclean：可中止的并发预清理，GC线程与应用线程并行运行。这一阶段标记 From 和 To 区对象可达的老年代对象，并处理被标记为 Dirty 的对象
   5. Final Remark：重新标记，需要暂停应用线程。这一阶段需要重新遍历并标记年轻代对象，遍历老年代的 Dirty ，并重新标记
   6. Concurrent Sweep：并发清理。清理所有未被标记的对象
   7. Concurrent Reset：并发重置。清理并重置 CMS GC 的各种状态信息，为下一次 GC 做准备
---

##### 四、G1 GC
1. G1 GC 采用标记整理算法，不会产生内存空间碎片
2. G1 能建立可预测的停顿时间模型，可以让使用者指定在某个时间片段内，消耗在垃圾收集上的时间不超过 N
3. G1 GC 把内存划分为同等大小的物理块，虽然还保留有年轻代和老年代的概念，但年轻代和老年代不再是物理隔离的，它们都是一部分同物理块的集合
4. 收集步骤：
   1. Initial Marking：初始标记阶段，这个阶段会触发一次普通的 Mintor GC ，会有短暂停顿
   2. Root Region Scanning，区域扫描阶段，程序运行过程中会回收 Survivor 区
   3. Concurrent Marking，并发标记阶段。在整个堆中进行并发标记，在并发标记阶段，如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的存活对象比例
   4. Remark, 再标记，会有短暂停顿.再标记阶段是用来收集“并发标记阶段”产生新的垃圾
   5. Cleanup，清除阶段，会有短暂停顿。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中
---

##### 五、简单对比
| | 内存分布 | 收集算法 |
| ---- | ---- | ---- |
| 串行 GC | 分代分布 | 复制算法、标记-压缩算法 |
| 并行 GC | 分代分布 | 复制算法、标记-压缩算法 |
| CMS GC | 分代分布 | 标记-清除算法 |
| G1 GC | 逻辑分代，物理混合分布 | 标记-整理算法 |

